<!-- Labyrinth Game -->
<!-- Andrew Cerrito -->
<!-- Grid code adapted from Yaroslav Bigus (http://ybigus.blogspot.com/) -->


<!DOCTYPE html>
<html lang="en">
	<head>
		<title>3D Table Test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>canvas {width: 100%; height: 100%}</style>
	</head>

	
	<body>

		<script src="js/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/physi.js"></script>
		<script src="js/csg.js"></script>
		<script src="js/ThreeCSG.js"></script>
		<script src="js/sb-1.4.1.js"></script>



		<script>

// ************ DECLARATIONS **************

		//physijs variables

		//'use strict';
		Physijs.scripts.worker = 'js/physijs_worker.js';
		Physijs.scripts.ammo = 'ammo.js';

		var container, stats;
		var camera, scene, renderer, ball;
		var mouseX = 0, mouseY = 0;
		var tempRotX = 0, tempRotZ = 0;

		// set limit to board rotations
		var rotLimitX = 0.5, rotLimitZ = 0.5;


		var planeCollide = false;


		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		// spacebrew stuff
		var ax = 0, ay = 0;
		// var random_id = Math.floor((Math.random() * 1000) + 1);
		var sb = new Spacebrew.Client("50.112.244.54", "labyrinth prototype ");
		sb.addSubscribe("tilt_x", "string");
		sb.addSubscribe("tilt_y", "string");
		sb.onStringMessage = onStringMessage;
		sb.connect();
		console.log("sb connect");


// ********* PROGRAM ***********

		init();
		loadCamera();
		loadScene();
		loadGround();
		//loadOuterWalls();
		loadBall();
		loadResetPlane();
		animate();

// ********* FUNCTIONS **********

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				// renderer and listeners

				// Detect for WebGL capability - if not, use canvas renderer
				if (Detector.webgl){
					renderer = new THREE.WebGLRenderer({antialias: true});
				}
				else {
					renderer = new THREE.CanvasRenderer();
				}
				
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setClearColor(0x87CEEB);
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				window.addEventListener( 'resize', onWindowResize, false );

				// KEYBOARD LISTENER FOR DEBUG - DELETE LATER:
				document.addEventListener("keydown",doKeyDown,false);
			}


			// camera - old values y 180 z 100
			function loadCamera() {
				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.x = 0;
				camera.position.y = 180;
				camera.position.z = 150;
			}


			// scene

			function loadScene() {
			scene = new Physijs.Scene();
			scene.setGravity(new THREE.Vector3(0,-100,0)); 

			var ambient = new THREE.AmbientLight( 0x101030 );
				//scene.add( ambient );

			var directionalLight = new THREE.DirectionalLight( 0xffeedd );
			directionalLight.position.set( 0, 10, 1);
			directionalLight.castShadow = true;
			directionalLight.shadowCameraVisible = true;
			scene.add( directionalLight );
			}


				// loading manager - unused for now

				// var manager = new THREE.LoadingManager();
				// manager.onProgress = function ( item, loaded, total ) {
				// console.log( item, loaded, total );
				// };

/*
				// ground surface - the bsp stuff is for putting a hole in the ground using ThreeCSG library,
				// but until I can figure out how to apply physics to a hole it's unused for now

				var box_w = 150, box_d = 1, box_h = 150;
				var box = new THREE.BoxGeometry(box_w, box_d, box_h);
				var box_mesh = new Physijs.BoxMesh(box);
				var box_bsp = new ThreeBSP(box_mesh);

				var cylinder = new THREE.CylinderGeometry(10,10,70,32);
				var cyl_mesh = new Physijs.CylinderMesh(cylinder);
				var cyl_bsp = new ThreeBSP(cyl_mesh);

				var subtract_bsp = box_bsp.subtract(cyl_bsp);
				var result = subtract_bsp.toGeometry();

*/				
			function loadGround() {
				
				// load level layout
				level = levelLayout();
		
				// shared ground + wall material
				box_material = Physijs.createMaterial(
					new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture('textures/balsa.jpg') }), 
					0.8, 
					0
				);

				
				// ground tile geometry
				box_w = 15, box_d = 1, box_h = 15;
				box = new THREE.BoxGeometry(box_w, box_d, box_h);

				// define piece to parent entire rest of board to, in order to make rotation less of a headache
				parent_piece = new Physijs.BoxMesh(box, box_material, 0);
				//parent_piece.__dirtyPosition = true;
				//parent_piece.__dirtyRotation = true;
				//parent_piece.position.x = (box_w * (level[0].length/2));
				//parent_piece.position.y = 15;
				//parent_piece.position.x = -level[0].length * 5;
    			
    			
				
				// read through level layout array and create rest of elements accordingly. parent them to parent piece
				for (var i = 0; i < level.length; i++) {
					for (var j = 0; j < level[i].length; j++) {
						switch (level[i][j]) {
			                case 0:
			                    addFloor(j, i, level.length, level[i].length);
			                    break;
			                case 1:
			                    addWall(j, i, level.length, level[i].length);
			                    break;
			                case 2:
			                    addHole(j, i, level.length, level[i].length);
			                    break;
			                case 3:
			                    addGoal(j, i, level.length, level[i].length);
			                    break;
			            }

					}
				}
				

				// load boundary walls - only responds to physics if called here?? not sure why.
				loadOuterWalls();

				// add parent piece
				scene.add(parent_piece);
			}


			function loadBall() {
				var ball_geometry = new THREE.SphereGeometry(5,32,32);
				var ball_material = Physijs.createMaterial(
					new THREE.MeshLambertMaterial({map: THREE.ImageUtils.loadTexture('textures/metal.jpg')}),
				 	0.9, // friction
				 	0  // bounciness
				 );

				ball = new Physijs.SphereMesh(ball_geometry, ball_material,100);
				ball.position.x = -(box_w * (level[0].length/2) + box_w/2) + box_w;
				ball.position.z = (box_w * (level[0].length/2) + box_w/2) - box_h;
				ball.position.y = 100;
				ball.castShadow = true;

				ball.addEventListener('collision', function(object) {
					//console.log("ball collision");

					});

				// load plane underneath board that knows when ball falls through
				loadResetPlane();

				scene.add( ball );

			}


				function addFloor(x, z, rows, cols) {

					var floor = new Physijs.BoxMesh(box, box_material, 0);
					
					// adjustments so that parent piece is in center of gamefield for rotation purposes:
					floor.position.x = -(box_w * (level[0].length/2) - box_w/2) + (x * box_w);
					floor.position.z = -(box_h * (level[0].length/2) - box_h/2) + (z * box_h);

					floor.receiveShadow = true;
					parent_piece.add(floor);

				}

				function addWall(x, z, rows, cols) {
					// wall tile geometry
					var wall_w = 15, wall_d = 8, wall_h = 15;
					var wall_geometry = new THREE.BoxGeometry(wall_w, wall_d, wall_h);

					var wall = new Physijs.BoxMesh(wall_geometry, box_material, 0);

					// same adjustments for rotation as above
					wall.position.x = -(wall_w * (level[0].length/2) - wall_w/2) + (x * wall_w);
					wall.position.z = -(wall_h * (level[0].length/2) - wall_h/2) + (z * wall_h);
					wall.position.y = wall_d/2;
					parent_piece.add(wall);

				}

				function addHole(x, z, rows, cols){

				}

				function addGoal(x, z, rows, cols){

				}

				function loadOuterWalls() {
					// outer wall material - basic material for no shadow casting
					var wall_material = Physijs.createMaterial(
					new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture('textures/balsa.jpg') }), 
					0.9, 
					0
					);

					// outer wall geometries
					var wall_w = 5, wall_d = 10, wall_h = 150;
					var vertWall = new THREE.BoxGeometry(wall_w, wall_d, wall_h);
					var horizWall = new THREE.BoxGeometry(wall_h+(2*wall_w), wall_d, wall_w);

					// add walls
					leftWall = new Physijs.BoxMesh(vertWall,wall_material, 0);
					leftWall.position.x = -(box_w * (level[0].length/2) + wall_w/2);
					leftWall.position.y = wall_d/2;
					parent_piece.add(leftWall);

					rightWall = new Physijs.BoxMesh(vertWall,wall_material, 0);
					rightWall.position.x = (box_w * (level[0].length/2) + wall_w/2);
					rightWall.position.y = wall_d/2;
					parent_piece.add(rightWall);

					topWall = new Physijs.BoxMesh(horizWall,wall_material, 0);
					topWall.position.z = (box_h * (level[0].length/2) + wall_w/2);
					topWall.position.y = wall_d/2;
					parent_piece.add(topWall);

					bottomWall = new Physijs.BoxMesh(horizWall,wall_material, 0);
					bottomWall.position.z = -(box_h * (level[0].length/2) + wall_w/2);
					bottomWall.position.y = wall_d/2;
					parent_piece.add(bottomWall);

				}

				function loadResetPlane() {
					var plane_geom = new THREE.BoxGeometry(600,1,600);
					var plane_material = new THREE.MeshBasicMaterial({transparent: true, opacity: 0.0});
					resetPlane = new Physijs.BoxMesh(plane_geom,plane_material, 0);

					resetPlane.position.y = -400;

					resetPlane.addEventListener('collision', function(object) {
					//console.log("plane collision");
					planeCollide = true;
					});
					scene.add(resetPlane);

				}

/*
				ground = new Physijs.BoxMesh(box,box_material,0);
				ground.receiveShadow = true;
*/

				// adding walls as child objects to ground

				// wall material
				// var wall_material = Physijs.createMaterial(
				// 	new THREE.MeshBasicMaterial({ map: THREE.ImageUtils.loadTexture('textures/balsa.jpg') }), 
				// 	0.9, 
				// 	0
				// );

				// wall geometries & meshes
				
				/*
				var wall_w = 5, wall_d = 10, wall_h = 150;
				var vertWall = new THREE.BoxGeometry(wall_w, wall_d, wall_h);
				var horizWall = new THREE.BoxGeometry(wall_h-(2*wall_w), wall_d, wall_w);
				
				var leftWall = new Physijs.BoxMesh(vertWall,wall_material);
				leftWall.position.x = ground.position.x - (box_w/2 - wall_w/2);
				leftWall.position.y = ground.position.y + wall_d/2;
				ground.add(leftWall);

				var rightWall = new Physijs.BoxMesh(vertWall,wall_material);
				rightWall.position.x = ground.position.x + (box_w/2 - wall_w/2);
				rightWall.position.y = ground.position.y + wall_d/2;
				ground.add(rightWall);

				var topWall = new Physijs.BoxMesh(horizWall,wall_material);
				topWall.position.z = ground.position.z - (box_h/2 - wall_w/2);
				topWall.position.y = ground.position.y + wall_d/2;
				ground.add(topWall);

				var bottomWall = new Physijs.BoxMesh(horizWall,wall_material);
				bottomWall.position.z = ground.position.z + (box_h/2 - wall_w/2);
				bottomWall.position.y = ground.position.y + wall_d/2;
				ground.add(bottomWall);


				// creates ground with hole:
				//ground = new Physijs.BoxMesh(result, box_material, 0);

				// ground without hole:
				scene.add(ground);
*/			

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			// KEYBOARD DEBUG CONTROLS - COMMENT OUT LATER
			function doKeyDown (e){

				// W: tilt phone up (neg y)
					if (e.keyCode == 87) {
						tempRotX +=.05;
					}

				// S: tilt phone down (pos y)
					if (e.keyCode == 83) {
						tempRotX -=.05;
					}
				// A: tilt phone right (pos x)
					if (e.keyCode == 65) {
						tempRotZ -=.05;
					}
				// D: tilt phone left (neg x)
					if (e.keyCode == 68) {
						tempRotZ +=.05;
					}

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {

				parent_piece.__dirtyPosition = true;
				parent_piece.__dirtyRotation = true;

				parent_piece.rotation.z = tempRotZ;
				parent_piece.rotation.x = tempRotX;

				parent_piece.rotation.z -= ax/600;
				parent_piece.rotation.x += ay/600;

				if (planeCollide == true) {
				scene.remove(parent_piece);
				scene.remove(ball);
				loadGround();
				loadBall();
				planeCollide = false;
				}
				


				tempRotZ -= ax/900;
				tempRotX += ay/500;
				console.log(" X rotation: " + tempRotX + "   Z rotation: " + tempRotZ);
				
				// rotation limits on game board
				if (tempRotZ >= rotLimitZ) tempRotZ = rotLimitZ;
				else if (tempRotZ <= -rotLimitZ) tempRotZ = -rotLimitZ;
				
				if (tempRotX  >= rotLimitX) tempRotX = rotLimitX;
				else if (tempRotX <= -rotLimitX) tempRotX = -rotLimitX;

				
				// mouse camera movement:

				//camera.position.x += ( mouseX - camera.position.x ) * .05;
				//camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );

				scene.simulate();  // run physics
				renderer.render( scene, camera );  // render scene

			}

			function onStringMessage(name, value) {
				if (name == "tilt_x") {
					ax = parseFloat(value);
				}
				else if (name == "tilt_y") {
					ay = parseFloat(value);
				}
				//console.log("test");
				//console.log("x: " + ax + " y: " + ay );
			}

	function levelLayout() {
		return [
		[0, 1, 0, 0, 0, 2, 1, 0, 0, 0],
		[0, 1, 0, 2, 0, 1, 1, 0, 3, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 2, 0],
		[0, 2, 0, 1, 1, 0, 2, 0, 1, 1],
		[0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 2, 0, 1, 1, 0, 2, 0],
		[1, 1, 0, 0, 0, 0, 0, 0, 0, 1],
		[0, 0, 0, 1, 0, 2, 0, 0, 0, 0],
		[0, 1, 0, 2, 0, 0, 0, 1, 2, 0],
		[0, 0, 0, 1, 0, 0, 0, 1, 0, 0]
		]
	}

	function getRadians(dgrs){
	var degrees = (Math.PI/180)*dgrs;
	return degrees;
	}

		</script>

	</body>
</html>