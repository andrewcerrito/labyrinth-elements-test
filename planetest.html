<!DOCTYPE html>
<html lang="en">
	<head>
		<title>3D Table Test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>canvas {width: 100%; height: 100%}</style>
	</head>

	
	<body>

		<script src="js/three.min.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/physi.js"></script>
		<script src="js/csg.js"></script>
		<script src="js/ThreeCSG.js"></script>
		<script src="js/sb-1.4.1.js"></script>



		<script>

// ************ DECLARATIONS **************

		//physijs variables

		//'use strict';
		Physijs.scripts.worker = 'js/physijs_worker.js';
		Physijs.scripts.ammo = 'ammo.js';

		var container, stats;
		var camera, scene, renderer, ball;
		var mouseX = 0, mouseY = 0;
		var tempRotX = 0, tempRotZ = 0;


		var windowHalfX = window.innerWidth / 2;
		var windowHalfY = window.innerHeight / 2;

		// spacebrew stuff
		
		var ax = 0, ay = 0;
		// var random_id = Math.floor((Math.random() * 1000) + 1);
		var sb = new Spacebrew.Client("50.112.244.54", "labyrinth prototype ");
		sb.addSubscribe("tilt_x", "string");
		sb.addSubscribe("tilt_y", "string");
		sb.onStringMessage = onStringMessage;
		sb.connect();
		console.log("sb connect");


// ********* PROGRAM ***********

		init();
		animate();

// ********* FUNCTIONS **********

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );


				// renderer and listeners

				// Detect for WebGL capability - if not, use canvas renderer
				if (Detector.webgl){
					renderer = new THREE.WebGLRenderer({antialias: true});
				}
				else {
					renderer = new THREE.CanvasRenderer();
				}
				
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				window.addEventListener( 'resize', onWindowResize, false );

				// KEYBOARD LISTENER FOR DEBUG - DELETE LATER:
				document.addEventListener("keydown",doKeyDown,false);


				// camera

				camera = new THREE.PerspectiveCamera( 35, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.x = 0;
				camera.position.y = 180;
				camera.position.z = 100;


				// scene

				scene = new Physijs.Scene();
				scene.setGravity(new THREE.Vector3(0,-100,0)); 

				var ambient = new THREE.AmbientLight( 0x101030 );
				//scene.add( ambient );

				var directionalLight = new THREE.DirectionalLight( 0xffeedd );
				directionalLight.position.set( 0, 10, 1);
				directionalLight.castShadow = true;
				directionalLight.shadowCameraVisible = true;
				scene.add( directionalLight );


				// loading manager - unused for now

				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
				console.log( item, loaded, total );
				};


				// ground surface - the bsp stuff is for putting a hole in the ground using ThreeCSG library,
				// but until I can figure out how to apply physics to a hole it's unused for now

				var box_w = 150, box_d = 1, box_h = 150;
				var box = new THREE.BoxGeometry(box_w, box_d, box_h);
				var box_mesh = new Physijs.BoxMesh(box);
				var box_bsp = new ThreeBSP(box_mesh);

				var cylinder = new THREE.CylinderGeometry(10,10,70,32);
				var cyl_mesh = new Physijs.CylinderMesh(cylinder);
				var cyl_bsp = new ThreeBSP(cyl_mesh);

				var subtract_bsp = box_bsp.subtract(cyl_bsp);
				var result = subtract_bsp.toGeometry();

				// ground material
				var box_material = Physijs.createMaterial(
					new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture('textures/balsa.jpg') }), 
					0.8, 
					0
				);

				ground = new Physijs.BoxMesh(box,box_material,0);
				ground.receiveShadow = true;


				// adding walls as child objects to ground

				// wall material
				var wall_material = Physijs.createMaterial(
					new THREE.MeshBasicMaterial({ map: THREE.ImageUtils.loadTexture('textures/balsa.jpg') }), 
					0.9, 
					0
				);

				// wall geometries & meshes
				var wall_w = 5, wall_d = 10, wall_h = 150;
				var vertWall = new THREE.BoxGeometry(wall_w, wall_d, wall_h);
				var horizWall = new THREE.BoxGeometry(wall_h-(2*wall_w), wall_d, wall_w);
				
				var leftWall = new Physijs.BoxMesh(vertWall,wall_material);
				leftWall.position.x = ground.position.x - (box_w/2 - wall_w/2);
				leftWall.position.y = ground.position.y + wall_d/2;
				ground.add(leftWall);

				var rightWall = new Physijs.BoxMesh(vertWall,wall_material);
				rightWall.position.x = ground.position.x + (box_w/2 - wall_w/2);
				rightWall.position.y = ground.position.y + wall_d/2;
				ground.add(rightWall);

				var topWall = new Physijs.BoxMesh(horizWall,wall_material);
				topWall.position.z = ground.position.z - (box_h/2 - wall_w/2);
				topWall.position.y = ground.position.y + wall_d/2;
				ground.add(topWall);

				var bottomWall = new Physijs.BoxMesh(horizWall,wall_material);
				bottomWall.position.z = ground.position.z + (box_h/2 - wall_w/2);
				bottomWall.position.y = ground.position.y + wall_d/2;
				ground.add(bottomWall);


				// creates ground with hole:
				//ground = new Physijs.BoxMesh(result, box_material, 0);

				// ground without hole:
				scene.add(ground);
				

				// ball

				var ball_geometry = new THREE.SphereGeometry(5,32,32);
				var ball_material = Physijs.createMaterial(
					new THREE.MeshLambertMaterial({ color: 0x00ff00 }),
				 	0.9, // friction
				 	0  // bounciness
				 );

				ball = new Physijs.SphereMesh(ball_geometry, ball_material,100);
				ball.position.y = 20;
				ball.castShadow = true;
				scene.add( ball );

			}

			function onWindowResize() {

				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			// KEYBOARD DEBUG CONTROLS - COMMENT OUT LATER
			function doKeyDown (e){

				// W: tilt phone up (neg y)
					if (e.keyCode == 87) {
						tempRotX +=.05;
					}

				// S: tilt phone down (pos y)
					if (e.keyCode == 83) {
						tempRotX -=.05;
					}
				// A: tilt phone right (pos x)
					if (e.keyCode == 65) {
						tempRotZ -=.05;
					}
				// D: tilt phone left (neg x)
					if (e.keyCode == 68) {
						tempRotZ +=.05;
					}

			}

			function onDocumentMouseMove( event ) {

				mouseX = ( event.clientX - windowHalfX ) / 2;
				mouseY = ( event.clientY - windowHalfY ) / 2;

			}

			//

			function animate() {

				requestAnimationFrame( animate );
				render();

			}

			function render() {
				ground.rotation.z = tempRotZ;
				ground.rotation.x = tempRotX;

				ground.__dirtyRotation = true; // needed for physijs rotation
				// ground.rotation.z -= ax/600;
				// ground.rotation.x += ay/600;

				tempRotZ -= ax/1000;
				tempRotX += ay/600;

				// mouse camera movement:

				//camera.position.x += ( mouseX - camera.position.x ) * .05;
				//camera.position.y += ( - mouseY - camera.position.y ) * .05;
				camera.lookAt( scene.position );

				scene.simulate();  // run physics
				renderer.render( scene, camera );  // render scene

			}

			function onStringMessage(name, value) {
				if (name == "tilt_x") {
					ax = parseFloat(value);
				}
				else if (name == "tilt_y") {
					ay = parseFloat(value);
				}
				console.log("test");
				console.log("x: " + ax + " y: " + ay );
			}

		</script>

	</body>
</html>